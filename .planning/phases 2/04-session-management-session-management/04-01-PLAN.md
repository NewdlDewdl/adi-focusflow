---
phase: 04-session-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/session-types.ts
  - src/lib/session-storage.ts
  - src/hooks/useSessionManager.ts
  - src/hooks/useFocusScore.ts
  - src/hooks/useFocusChime.ts
  - src/hooks/useAICoaching.ts
autonomous: true

must_haves:
  truths:
    - "Session state machine transitions correctly through idle -> running -> paused -> running -> ended"
    - "Completed sessions persist in localStorage and survive page reload"
    - "Focus score, chime state, and coaching state reset to initial values when a new session starts"
    - "Streak calculation returns correct consecutive day count from stored sessions (verified with gap, same-day, boundary scenarios)"
    - "Personal bests calculation returns correct max values across all stored sessions (verified with empty, single, multi-session scenarios)"
  artifacts:
    - path: "src/lib/session-types.ts"
      provides: "SessionPhase, SessionState, SessionAction, StoredSession, FocusSnapshot types"
      contains: "SessionPhase"
    - path: "src/lib/session-storage.ts"
      provides: "loadSessions, saveSession, calculateStreak, getPersonalBests functions"
      exports: ["loadSessions", "saveSession", "calculateStreak", "getPersonalBests"]
    - path: "src/hooks/useSessionManager.ts"
      provides: "Session lifecycle state machine via useReducer with START/PAUSE/RESUME/END/TICK/DISTRACTION actions"
      exports: ["useSessionManager"]
  key_links:
    - from: "src/hooks/useSessionManager.ts"
      to: "src/lib/session-types.ts"
      via: "imports SessionState, SessionAction, SessionPhase types"
      pattern: "import.*from.*session-types"
    - from: "src/hooks/useSessionManager.ts"
      to: "src/lib/session-storage.ts"
      via: "calls saveSession on END action effect"
      pattern: "saveSession"
    - from: "src/hooks/useFocusScore.ts"
      to: "reset function"
      via: "exposes reset() that clears score refs to 100"
      pattern: "reset.*currentScoreRef"
---

<objective>
Build the session management foundation: types, state machine, persistence layer, and reset capabilities for existing hooks.

Purpose: All session UI (controls, metrics, summary, history) depends on a reliable state machine and storage layer. This plan creates the backbone that plans 04-02 and 04-03 consume. By separating foundation from UI, we keep each plan focused and within context budget.

Output: Three new files (session-types.ts, session-storage.ts, useSessionManager.ts) and reset functions added to three existing hooks (useFocusScore, useFocusChime, useAICoaching).
</objective>

<execution_context>
@/Users/adiga/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adiga/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-session-management-session-management/04-RESEARCH.md
@src/hooks/useFocusScore.ts
@src/hooks/useFocusChime.ts
@src/hooks/useAICoaching.ts
@src/lib/coaching-engine.ts
@src/lib/focus-algorithm.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session types and localStorage persistence layer</name>
  <files>src/lib/session-types.ts, src/lib/session-storage.ts</files>
  <action>
Create `src/lib/session-types.ts` with these types:

```typescript
type SessionPhase = "idle" | "running" | "paused" | "ended";

interface FocusSnapshot {
  time: number;   // Unix ms timestamp
  score: number;  // 0-100
}

interface SessionState {
  phase: SessionPhase;
  startTime: number | null;
  pausedAt: number | null;
  totalPausedMs: number;
  snapshots: FocusSnapshot[];
  distractionCount: number;
  focusedMs: number;
}

type SessionAction =
  | { type: "START" }
  | { type: "PAUSE" }
  | { type: "RESUME" }
  | { type: "END" }
  | { type: "TICK"; score: number; timestamp: number }
  | { type: "DISTRACTION" };

interface StoredSession {
  id: string;
  startTime: number;
  endTime: number;
  totalDurationMs: number;
  pausedDurationMs: number;
  averageScore: number;
  focusedPercentage: number;
  distractionCount: number;
  peakScore: number;
  longestFocusStreakMs: number;
  snapshots: FocusSnapshot[];  // Downsampled for storage
}
```

Export all types.

Create `src/lib/session-storage.ts` with these functions:

1. `loadSessions(): StoredSession[]` - Read from localStorage key `"focusflow_sessions"`, return empty array on parse error or missing data. Wrap in try/catch.

2. `saveSession(session: StoredSession): void` - Append to existing sessions array, trim to most recent 100 sessions, write to localStorage. Wrap in try/catch. Log errors but never throw.

3. `downsampleSnapshots(snapshots: FocusSnapshot[], maxPoints: number): FocusSnapshot[]` - Reduce snapshot count for storage. Use evenly-spaced sampling: for N input snapshots and M maxPoints, pick every Math.ceil(N/M)th snapshot, always including first and last. Default maxPoints = 120 (one per ~30 seconds for a 60-min session).

4. `calculateStreak(sessions: StoredSession[]): number` - Get unique dates using `startTime` (not endTime) with `toLocaleDateString("en-CA")` for YYYY-MM-DD. Sort descending. Streak must start from today or yesterday. Walk backwards checking each date is exactly 1 day before the previous. Return streak count (0 if no recent sessions).

5. `getPersonalBests(sessions: StoredSession[]): { longestFocusStreakMs: number; highestScore: number; longestSessionMs: number }` - Return max of each metric across all sessions, defaulting to 0 for empty arrays.

6. `computeSessionSummary(state: SessionState): Omit<StoredSession, "id">` - From a SessionState that has phase "ended", compute: endTime (Date.now()), totalDurationMs (endTime - startTime - totalPausedMs), pausedDurationMs, averageScore (mean of snapshot scores), focusedPercentage (focusedMs / totalDurationMs * 100), distractionCount, peakScore (max snapshot score, default 100), longestFocusStreakMs (longest consecutive run of snapshots with score >= 70, multiplied by 3000ms tick interval), and downsampled snapshots (call downsampleSnapshots with maxPoints=120).

Use `crypto.randomUUID()` for session IDs (called in the hook, not in this module).

IMPORTANT: All localStorage operations MUST be wrapped in try/catch. Never let storage errors crash the app.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify types compile without errors. Grep for all exported functions to confirm they exist:
```bash
grep -n "export function\|export type\|export interface" src/lib/session-types.ts src/lib/session-storage.ts
```

**Verify calculateStreak logic with these scenarios** (write a temporary Node script or inline console checks):
1. Empty sessions array -> returns 0
2. One session today -> returns 1
3. One session yesterday -> returns 1
4. One session 2 days ago (with no session yesterday or today) -> returns 0 (streak broken)
5. Sessions on today + yesterday + day before -> returns 3
6. Sessions on today + yesterday + gap + 3 days ago -> returns 2 (gap breaks streak)
7. Multiple sessions on the same day -> counted as one day (streak = 1 if only today)
8. Boundary: session at 11:59 PM and 12:01 AM -> counted as two separate days (consecutive if adjacent)

**Verify getPersonalBests logic with these scenarios:**
1. Empty sessions array -> returns { longestFocusStreakMs: 0, highestScore: 0, longestSessionMs: 0 }
2. Single session -> returns that session's values
3. Multiple sessions -> returns the max of each metric across all sessions (e.g., session A has highest score, session B has longest focus streak -- each best comes from the correct session)
4. All sessions have identical values -> returns that value for each metric

If any scenario fails, fix the implementation before proceeding.
  </verify>
  <done>session-types.ts exports SessionPhase, SessionState, SessionAction, StoredSession, FocusSnapshot. session-storage.ts exports loadSessions, saveSession, downsampleSnapshots, calculateStreak, getPersonalBests, computeSessionSummary. All functions handle errors gracefully. calculateStreak correctly handles consecutive day counting, gap detection, and same-day deduplication. getPersonalBests correctly returns max values across all sessions.</done>
</task>

<task type="auto">
  <name>Task 2: Create useSessionManager hook and add reset functions to existing hooks</name>
  <files>src/hooks/useSessionManager.ts, src/hooks/useFocusScore.ts, src/hooks/useFocusChime.ts, src/hooks/useAICoaching.ts</files>
  <action>
**Part A: Create `src/hooks/useSessionManager.ts`**

Implement a `useSessionManager` hook using `useReducer` with the `sessionReducer` pure function:

1. The reducer handles all SessionAction types as described in the research:
   - START: Reset to running state with startTime=Date.now(), clear snapshots/metrics
   - PAUSE: Set phase to "paused", record pausedAt (only if currently running)
   - RESUME: Set phase to "running", accumulate totalPausedMs, clear pausedAt (only if currently paused)
   - END: Set phase to "ended" (only if running or paused; if paused, accumulate final pause duration)
   - TICK: Append snapshot (score + timestamp), accumulate focusedMs if score >= 70 (add 3000ms per tick). Only process if phase is "running".
   - DISTRACTION: Increment distractionCount (only if running)

2. The hook returns:
   - `session: SessionState` (current state)
   - `start()` - dispatches START
   - `pause()` - dispatches PAUSE
   - `resume()` - dispatches RESUME
   - `end()` - dispatches END, computes summary via `computeSessionSummary`, calls `saveSession` with `crypto.randomUUID()` as id. Only saves if session was longer than 60 seconds (totalDurationMs > 60000). Returns the StoredSession or null.
   - `tick(score: number)` - dispatches TICK with score and Date.now()
   - `recordDistraction()` - dispatches DISTRACTION

3. The initial state: phase "idle", all nulls/zeros/empty arrays.

4. DO NOT run a timer inside this hook. The caller (DetectionProvider or page) dispatches TICK actions. The hook is a pure state container.

**Part B: Add reset() to useFocusScore**

Add a `reset` function to the return value of `useFocusScore`:

```typescript
const reset = useCallback(() => {
  currentScoreRef.current = 100;
  lastScoreUpdateRef.current = Date.now();
  recentInstantScoresRef.current = [];
  setScore(100);
  setHistory([]);
}, []);
```

Add `reset` to the return object. Do NOT reset calibration state -- the webcam is still running, calibration carries over between sessions.

**Part C: Add reset() to useFocusChime**

Read useFocusChime.ts first. Add a `reset` function that clears:
- baseline score ref back to initial value (100)
- chimeCount back to 0
- any interval/timer refs
- last chime timestamp

Return `reset` alongside existing return values.

**Part D: Add reset() to useAICoaching**

Read useAICoaching.ts first. Add a `reset` function that clears:
- nudge state back to initial (idle, tier gentle, no active nudge)
- coaching engine state back to initial
- Any playing audio state
- Do NOT clear the pre-cache audio data (it's expensive to regenerate)

Return `reset` alongside existing return values.

IMPORTANT for all resets: Use `useCallback` with empty deps. These reset functions must have stable references.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Check that all reset functions are exported:
```bash
grep -n "reset" src/hooks/useFocusScore.ts src/hooks/useFocusChime.ts src/hooks/useAICoaching.ts
grep -n "export function useSessionManager" src/hooks/useSessionManager.ts
```
Run `npm run build` to confirm full build succeeds.
  </verify>
  <done>useSessionManager hook exists with START/PAUSE/RESUME/END/TICK/DISTRACTION actions, saves completed sessions (>60s) to localStorage via session-storage. useFocusScore, useFocusChime, and useAICoaching each expose a stable reset() callback that clears internal refs without affecting detection pipeline or calibration.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` succeeds
3. All types in session-types.ts are exported and importable
4. All functions in session-storage.ts are exported
5. useSessionManager hook exports start/pause/resume/end/tick/recordDistraction
6. useFocusScore, useFocusChime, useAICoaching each export a reset function
7. No existing functionality is broken (detection, scoring, coaching still work)
</verification>

<success_criteria>
- Session state machine transitions correctly: idle->running->paused->running->ended
- StoredSession can be serialized to/from localStorage without data loss
- calculateStreak returns correct day count for consecutive sessions
- Reset functions clear scoring/chime/coaching state without affecting webcam or calibration
- Zero new npm dependencies added
- Full build passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-session-management-session-management/04-01-SUMMARY.md`
</output>
