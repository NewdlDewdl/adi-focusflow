---
phase: 07-fix-face-mesh-color-calibration-and-focus-score-accuracy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/focus-algorithm.ts
  - src/hooks/useFocusScore.ts
autonomous: true

must_haves:
  truths:
    - "User looking directly at camera sees score stay at 100 for extended periods"
    - "Score only decreases after 3+ consecutive seconds of sustained below-threshold readings"
    - "Score never increases once it has dropped (monotonically decreasing)"
    - "Normal head and eye micro-movements do not trigger score decay"
  artifacts:
    - path: "src/lib/focus-algorithm.ts"
      provides: "Fixed instant score formula with correct gaze bearing center and rebalanced weights"
      contains: "GAZE_CENTER_DEG"
    - path: "src/hooks/useFocusScore.ts"
      provides: "Sustained distraction timer with consecutive-second requirement"
      contains: "consecutiveDistractedRef"
  key_links:
    - from: "src/lib/focus-algorithm.ts"
      to: "src/hooks/useFocusScore.ts"
      via: "computeInstantFocusScore called in useEffect"
      pattern: "computeInstantFocusScore\\(input"
    - from: "src/hooks/useFocusScore.ts"
      to: "src/components/detection/DetectionProvider.tsx"
      via: "useFocusScore hook consumed by DetectionProvider"
      pattern: "useFocusScore\\(result\\)"
---

<objective>
Fix the focus scoring algorithm to eliminate premature score decay and produce accurate instant scores.

Purpose: The current scoring pipeline has three critical bugs causing the score to decrease even when the user is looking directly at the camera: (1) gaze bearing is measured from 0 degrees instead of ~90 degrees (Human.js center), (2) gaze weight is too high relative to the noisy gaze data, and (3) a single 3-second average below threshold triggers decay without requiring sustained distraction. These bugs make the focus score unreliable and undermine the entire feedback loop.

Output: Corrected focus-algorithm.ts with proper gaze center and rebalanced weights, and rewritten useFocusScore.ts scoring logic with sustained distraction requirement.
</objective>

<execution_context>
@/Users/adiga/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adiga/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-fix-face-mesh-color-calibration-and-focus-score-accuracy/07-RESEARCH.md
@src/lib/focus-algorithm.ts
@src/hooks/useFocusScore.ts
@src/components/detection/DetectionProvider.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix gaze bearing center and rebalance scoring weights</name>
  <files>src/lib/focus-algorithm.ts</files>
  <action>
Fix the `extractFocusInput()` function and `computeInstantFocusScore()` function, and update `DEFAULT_FOCUS_CONFIG`:

**extractFocusInput() -- Fix gaze bearing interpretation:**
The current code computes `gazeBearingDeg: Math.abs((face.rotation.gaze.bearing * 180) / Math.PI)`. Human.js gaze bearing is centered at ~PI/2 radians (~90 degrees) when looking straight ahead, NOT at 0 degrees. Change the extraction to compute the DEVIATION from center:
```typescript
const bearingDeg = (face.rotation.gaze.bearing * 180) / Math.PI;
const GAZE_CENTER_DEG = 90;
gazeBearingDeg: Math.abs(bearingDeg - GAZE_CENTER_DEG)
```
This means `gazeBearingDeg` now represents how far from "looking straight" the user's gaze is (0 = looking at camera, 30 = looking away). Add `GAZE_CENTER_DEG` as a named constant at the top of the file.

**computeInstantFocusScore() -- Fix gaze sub-score:**
The gaze sub-score currently multiplies `gazeDirectionScore * gazeStrength`. Human.js gazeStrength is a displacement metric (NOT confidence), so low values (0.1-0.3) mean "looking near center" and high values mean "looking away." This is the OPPOSITE of how it's being used. When the user is looking at the camera, gazeStrength is LOW, which suppresses the gaze sub-score.

Fix: When face is detected, apply a floor of 0.5 to gazeStrength to prevent it from suppressing the direction score during focused gaze:
```typescript
const effectiveStrength = input.faceDetected ? Math.max(0.5, input.gazeStrength) : 0;
const gazeScore = gazeDirectionScore * effectiveStrength;
```

**DEFAULT_FOCUS_CONFIG -- Rebalance weights:**
- `headPoseWeight`: 0.5 -> 0.6 (head pose is the most reliable signal)
- `gazeWeight`: 0.4 -> 0.2 (gaze data is noisy, reduce its impact)
- `facePresenceWeight`: 0.1 -> 0.2 (face not detected = definitely distracted)
- `gazeThresholdDeg`: 25 -> 30 (wider tolerance for noisy gaze data)

Keep all other config values unchanged. Keep the `applyEMA` and `applyHysteresis` functions unchanged (they exist for backward compatibility even though the new scoring model in useFocusScore doesn't use them directly).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Manually review that:
1. GAZE_CENTER_DEG = 90 is defined as a constant
2. extractFocusInput computes deviation from 90 degrees (not absolute from 0)
3. computeInstantFocusScore applies Math.max(0.5, input.gazeStrength) floor
4. DEFAULT_FOCUS_CONFIG has headPoseWeight=0.6, gazeWeight=0.2, facePresenceWeight=0.2, gazeThresholdDeg=30
  </verify>
  <done>
Instant focus score formula correctly measures gaze deviation from 90-degree center, applies strength floor, and uses rebalanced weights. A user looking directly at the camera should now produce instant scores of 85-100 (up from the previous 55-85).
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement sustained distraction timer with consecutive-second requirement</name>
  <files>src/hooks/useFocusScore.ts</files>
  <action>
Rewrite the scoring evaluation logic in the main `useEffect` to require 3+ consecutive seconds of sustained below-threshold readings before any score penalty. The current logic checks every 3 seconds but applies a penalty on a single below-threshold evaluation.

**Add new constants at the top of the file (outside the hook):**
```typescript
const DISTRACTED_THRESHOLD = 45;     // Average instant score below this = distracted
const SUSTAINED_SECONDS_REQUIRED = 3; // Must be distracted this many consecutive evaluations
const EVAL_INTERVAL_MS = 1000;        // Evaluate every 1 second (not every 3 seconds)
```

**Add a new ref inside the hook:**
```typescript
const consecutiveDistractedRef = useRef(0); // Count of consecutive distracted evaluations
```

**Replace the scoring evaluation block** (the section starting at "Check if 3 seconds have passed" through the end of `shouldUpdateScore` block) with:

1. Check if 1 second (EVAL_INTERVAL_MS) has passed since last evaluation
2. If yes, compute the average of recent instant scores
3. If average < DISTRACTED_THRESHOLD:
   - Increment `consecutiveDistractedRef.current`
4. If average >= DISTRACTED_THRESHOLD:
   - Reset `consecutiveDistractedRef.current` to 0 (user is focused, reset the counter)
5. If `consecutiveDistractedRef.current >= SUSTAINED_SECONDS_REQUIRED`:
   - Decrease score by 1 (Math.max(0, currentScoreRef.current - 1))
   - Update React state and append to history
   - Do NOT reset the counter (keep penalizing every second while distracted)
6. If distraction counter is below the required threshold:
   - Score stays the same. Do NOT increase. No else branch for recovery.

**Update lastScoreUpdateRef:** Rename to `lastEvalTimeRef` for clarity. Set it on every evaluation (not just when score changes).

**Keep everything else unchanged:** The calibration logic, the progress bar animation, the instant score tracking, the rolling average buffer, updateConfig, and reset function all stay the same.

**Update the reset function** to also reset `consecutiveDistractedRef.current = 0`.

**Remove old console.log statements** that reference "UNFOCUSED" / "FOCUSED" and replace with a single log:
```typescript
console.log(`[Score] Eval: avg=${avgInstantScore.toFixed(0)}, consecutive=${consecutiveDistractedRef.current}/${SUSTAINED_SECONDS_REQUIRED}, score=${newScore}`);
```
Log this only when a score change occurs (not every second) to reduce console noise.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Run `npm run build` to confirm successful build. Manually review that:
1. EVAL_INTERVAL_MS is 1000 (not 3000)
2. consecutiveDistractedRef exists and is initialized to 0
3. Score only decreases when consecutiveDistractedRef.current >= SUSTAINED_SECONDS_REQUIRED (3)
4. consecutiveDistractedRef resets to 0 when average >= DISTRACTED_THRESHOLD
5. There is NO code path that increases the score
6. reset() clears consecutiveDistractedRef
  </verify>
  <done>
Score evaluation runs every 1 second, requires 3+ consecutive distracted evaluations before any penalty, never increases, and resets the distraction counter when the user refocuses. This eliminates premature score decay from momentary gaze noise.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` succeeds
3. The scoring pipeline flow is: extractFocusInput (gaze centered at 90deg) -> computeInstantFocusScore (rebalanced weights, strength floor) -> rolling average -> sustained distraction check (3 consecutive seconds) -> monotonic decrease only
4. No code path exists to increase the displayed score
</verification>

<success_criteria>
- Gaze bearing deviation measured from 90-degree center (not 0)
- Gaze strength floored at 0.5 when face detected
- Weights rebalanced: head=0.6, gaze=0.2, face=0.2
- Score evaluated every 1 second with 3-consecutive-second sustained distraction requirement
- Score is strictly monotonically decreasing (never increases)
- Build passes with no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-fix-face-mesh-color-calibration-and-focus-score-accuracy/07-01-SUMMARY.md`
</output>
