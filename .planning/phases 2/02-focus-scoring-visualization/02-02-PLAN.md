---
phase: 02-focus-scoring-visualization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/focus-algorithm.ts
  - src/hooks/useFocusScore.ts
autonomous: true

must_haves:
  truths:
    - "Focus score computes a 0-100 value from head pose + gaze data"
    - "Score uses EMA smoothing so brief glances away do not cause score drops"
    - "Score uses hysteresis so the displayed value does not oscillate rapidly"
    - "Score sensitivity is configurable via updateConfig"
  artifacts:
    - path: "src/lib/focus-algorithm.ts"
      provides: "Pure scoring functions: computeInstantFocusScore, applyEMA, applyHysteresis, extractFocusInput"
      exports: ["computeInstantFocusScore", "applyEMA", "applyHysteresis", "extractFocusInput", "DEFAULT_FOCUS_CONFIG"]
    - path: "src/hooks/useFocusScore.ts"
      provides: "React hook consuming detection result, producing smoothed score + history"
      exports: ["useFocusScore"]
  key_links:
    - from: "src/hooks/useFocusScore.ts"
      to: "src/lib/focus-algorithm.ts"
      via: "import"
      pattern: "import.*focus-algorithm"
    - from: "src/hooks/useFocusScore.ts"
      to: "src/lib/detection-types.ts"
      via: "import DetectionResult type"
      pattern: "import.*DetectionResult"
    - from: "src/lib/focus-algorithm.ts"
      to: "src/lib/detection-types.ts"
      via: "import for extractFocusInput"
      pattern: "import.*DetectionResult"
---

<objective>
Create the focus scoring algorithm as a pure TypeScript function and the useFocusScore React hook that consumes detection results and produces a smoothed, hysteresis-protected 0-100 focus score with configurable sensitivity.

Purpose: This is the core novel engineering work of Phase 2. The algorithm converts raw Human.js detection data (yaw, pitch, gaze bearing, gaze strength, face presence) into a trustworthy focus score. The pure function + hook pattern keeps scoring testable and separate from React rendering. Satisfies SCORE-01, SCORE-02, SCORE-03, SCORE-06.

Output: `focus-algorithm.ts` with pure scoring functions, `useFocusScore.ts` hook ready to be consumed by visualization components in Plan 03.
</objective>

<execution_context>
@/Users/adiga/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adiga/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-focus-scoring-visualization/02-RESEARCH.md
@src/lib/detection-types.ts
@src/hooks/useHumanDetection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create focus scoring algorithm (pure functions)</name>
  <files>src/lib/focus-algorithm.ts</files>
  <action>
    Create `src/lib/focus-algorithm.ts` with the following exports. This file has ZERO React dependencies -- pure TypeScript math.

    **Types:**
    - `FocusInput`: { yawDeg, pitchDeg, gazeBearingDeg, gazeStrength, faceDetected }
    - `FocusConfig`: { headPoseWeight (0.5), gazeWeight (0.4), facePresenceWeight (0.1), yawThresholdDeg (30), pitchThresholdDeg (25), gazeThresholdDeg (25), emaAlpha (0.15), dropThreshold (8), recoverThreshold (5) }
    - `EMAState`: { value: number, initialized: boolean }
    - `DEFAULT_FOCUS_CONFIG` constant with the defaults above

    **Functions:**

    1. `extractFocusInput(result: DetectionResult | null): FocusInput`
       - If result is null or no faces: return faceDetected: false with zeroed angles
       - Use first face (result.faces[0])
       - If face.rotation is null: return faceDetected: true with zeroed angles
       - Convert rotation.angle.yaw/pitch from radians to degrees: `(value * 180) / Math.PI`
       - Convert rotation.gaze.bearing from radians to degrees
       - Use Math.abs() for bearing -- looking left and right are equally "distracted"
       - Pass through gazeStrength directly (already 0-1)
       - Import DetectionResult from @/lib/detection-types

    2. `computeInstantFocusScore(input: FocusInput, config?: FocusConfig): number`
       - If !faceDetected: return 0
       - Head pose sub-score: average of yawScore and pitchScore
         - yawScore = max(0, 1 - abs(yawDeg) / yawThresholdDeg)
         - pitchScore = max(0, 1 - abs(pitchDeg) / pitchThresholdDeg)
       - Gaze sub-score: gazeDirectionScore * gazeStrength
         - gazeDirectionScore = max(0, 1 - abs(gazeBearingDeg) / gazeThresholdDeg)
       - Face presence sub-score: 1 if faceDetected, 0 if not
       - Weighted sum: headPoseScore * headPoseWeight + gazeScore * gazeWeight + faceScore * facePresenceWeight
       - Return Math.round(raw * 100), clamped to 0-100

    3. `applyEMA(instantScore: number, state: EMAState, alpha: number): { score: number; state: EMAState }`
       - If not initialized: return instantScore as-is, mark initialized
       - smoothed = alpha * instantScore + (1 - alpha) * state.value
       - Return Math.round(smoothed) and updated state

    4. `applyHysteresis(smoothedScore: number, displayedScore: number, config: FocusConfig): number`
       - If diff < -dropThreshold: return smoothedScore (significant drop)
       - If diff > recoverThreshold: return smoothedScore (significant recovery)
       - Otherwise: return displayedScore (within hysteresis band, no change)

    See 02-RESEARCH.md "Focus Scoring Algorithm" code example for full implementation reference.
  </action>
  <verify>
    - `src/lib/focus-algorithm.ts` exists
    - Exports: FocusInput, FocusConfig, EMAState, DEFAULT_FOCUS_CONFIG, extractFocusInput, computeInstantFocusScore, applyEMA, applyHysteresis
    - `npx tsc --noEmit` compiles without errors
    - Quick sanity: computeInstantFocusScore with centered face (yaw=0, pitch=0, gaze=0, strength=1, detected=true) returns ~100
    - Quick sanity: computeInstantFocusScore with turned face (yaw=30, pitch=0, gaze=0, strength=1, detected=true) returns a reduced score
    - Quick sanity: computeInstantFocusScore with no face returns 0
  </verify>
  <done>
    Pure focus scoring functions created. computeInstantFocusScore returns 100 for centered face, 0 for no face, and reduced scores for head/gaze deviation. EMA and hysteresis functions correctly smooth and stabilize scores.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useFocusScore hook</name>
  <files>src/hooks/useFocusScore.ts</files>
  <action>
    Create `src/hooks/useFocusScore.ts` as a 'use client' hook that wraps the pure scoring functions for React consumption.

    **Interface:**
    ```typescript
    function useFocusScore(
      result: DetectionResult | null,
      configOverrides?: Partial<FocusConfig>
    ): {
      score: number;                              // Current displayed score (0-100)
      history: { time: number; score: number }[];  // Rolling history for sparkline
      config: FocusConfig;                         // Current config
      updateConfig: (partial: Partial<FocusConfig>) => void;  // For sensitivity tuning
    }
    ```

    **Implementation:**
    - State: score (useState, init 0), history (useState, init []), config (useState, merged with overrides)
    - Refs: emaRef (EMAState, init { value: 0, initialized: false }), displayedScoreRef (number, init 0)
    - useEffect on [result, config]:
      1. If result is null, return early
      2. Call extractFocusInput(result)
      3. Call computeInstantFocusScore(input, config)
      4. Call applyEMA(instant, emaRef.current, config.emaAlpha) -- update emaRef
      5. Call applyHysteresis(smoothed, displayedScoreRef.current, config) -- update displayedScoreRef
      6. setScore(displayed)
      7. Append { time: Date.now(), score: displayed } to history, cap at MAX_HISTORY_LENGTH (300 entries = ~60s at 5 Hz)
    - updateConfig: useCallback that merges partial into config state

    **Important details:**
    - MAX_HISTORY_LENGTH = 300 (60 seconds of data at 5 Hz detection rate)
    - Use refs for EMA state and displayed score to avoid unnecessary re-renders
    - The effect should NOT reset EMA state when config changes -- only use the new config going forward
    - Import all pure functions from @/lib/focus-algorithm

    See 02-RESEARCH.md "useFocusScore Hook" code example for reference.
  </action>
  <verify>
    - `src/hooks/useFocusScore.ts` exists with 'use client' directive
    - Exports: useFocusScore
    - `npx tsc --noEmit` compiles without errors
    - Hook imports from focus-algorithm.ts and detection-types.ts
  </verify>
  <done>
    useFocusScore hook created. Accepts DetectionResult, produces smoothed score with EMA + hysteresis, maintains rolling history for sparkline, and exposes updateConfig for sensitivity tuning.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `focus-algorithm.ts` exports all required types and functions
3. `useFocusScore.ts` imports from focus-algorithm and detection-types correctly
4. Algorithm produces sensible scores: 100 for centered, 0 for absent, gradual reduction for deviation
</verification>

<success_criteria>
- Pure scoring algorithm in focus-algorithm.ts with no React dependencies
- useFocusScore hook ready to consume DetectionResult and produce smoothed score + history
- EMA smoothing prevents per-frame score jumps
- Hysteresis prevents rapid oscillation
- Config is updatable for sensitivity tuning (SCORE-06)
</success_criteria>

<output>
After completion, create `.planning/phases/02-focus-scoring-visualization/02-02-SUMMARY.md`
</output>
