---
phase: 04-session-management
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/app/session/page.tsx
  - src/components/detection/DetectionProvider.tsx
  - src/components/session/SessionControls.tsx
  - src/components/session/SessionSummary.tsx
  - src/components/session/SessionTimeline.tsx
autonomous: true

must_haves:
  truths:
    - "User can start a focus session with one click and see an elapsed timer"
    - "User can pause, resume, and end the session via visible controls"
    - "Detection pipeline keeps running during pause (no re-warmup on resume)"
    - "User sees live metrics (focused time, distraction count) during session"
    - "User sees comprehensive session summary after ending (total time, avg score, focused %, timeline chart)"
    - "Focus score resets to 100 on new session start"
  artifacts:
    - path: "src/components/session/SessionControls.tsx"
      provides: "Start/Pause/Resume/End buttons with elapsed timer display"
      contains: "SessionControls"
    - path: "src/components/session/SessionSummary.tsx"
      provides: "Post-session overlay with stats and timeline chart"
      contains: "SessionSummary"
    - path: "src/components/session/SessionTimeline.tsx"
      provides: "Recharts AreaChart showing focus score over session duration"
      contains: "SessionTimeline"
    - path: "src/app/session/page.tsx"
      provides: "Session page orchestrating idle/running/ended UI states"
      contains: "useSessionManager"
  key_links:
    - from: "src/app/session/page.tsx"
      to: "src/hooks/useSessionManager.ts"
      via: "imports and calls useSessionManager for session lifecycle"
      pattern: "useSessionManager"
    - from: "src/app/session/page.tsx"
      to: "src/components/detection/DetectionProvider.tsx"
      via: "passes session state props (phase, tick, recordDistraction, reset functions)"
      pattern: "DetectionProvider.*session"
    - from: "src/components/session/SessionSummary.tsx"
      to: "src/components/session/SessionTimeline.tsx"
      via: "renders timeline chart with session snapshots"
      pattern: "SessionTimeline"
    - from: "src/components/detection/DetectionProvider.tsx"
      to: "src/hooks/useFocusScore.ts"
      via: "calls reset() on session start, gates TICK dispatch on sessionPhase === running"
      pattern: "reset.*sessionPhase"
    - from: "src/app/session/page.tsx"
      to: "src/lib/session-storage.ts"
      via: "calls loadSessions/calculateStreak/getPersonalBests on mount AND on session dismiss to refresh dashboard data"
      pattern: "refreshDashboardData|loadSessions"
---

<objective>
Wire the session lifecycle into the session page and detection provider, creating the complete running experience: start -> live metrics -> pause/resume -> end -> summary.

Purpose: This plan transforms the current "auto-start detection" page into a proper session-based experience where users control when focus tracking begins, see live performance metrics, and receive a comprehensive summary after ending. The detection pipeline continues running even during pause to avoid re-warmup delays.

Output: Rewritten session/page.tsx orchestrating session states, SessionControls component with timer, DetectionProvider accepting session props, SessionSummary overlay with SessionTimeline chart.
</objective>

<execution_context>
@/Users/adiga/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adiga/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-session-management-session-management/04-RESEARCH.md
@.planning/phases/04-session-management-session-management/04-01-SUMMARY.md
@src/app/session/page.tsx
@src/components/detection/DetectionProvider.tsx
@src/components/scoring/StatCards.tsx
@src/components/scoring/FocusSparkline.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SessionControls, SessionTimeline, and SessionSummary components</name>
  <files>src/components/session/SessionControls.tsx, src/components/session/SessionTimeline.tsx, src/components/session/SessionSummary.tsx</files>
  <action>
**SessionControls.tsx** - Session control bar with timer display:

- Props: `phase: SessionPhase`, `startTime: number | null`, `totalPausedMs: number`, `focusedMs: number`, `distractionCount: number`, `onStart: () => void`, `onPause: () => void`, `onResume: () => void`, `onEnd: () => void`
- When phase is "idle": render a large "Start Focus Session" button with Play icon (lucide-react). Centered, prominent CTA styling.
- When phase is "running" or "paused": render a horizontal control bar with:
  - Elapsed timer (mm:ss format) using wall-clock math: `Date.now() - startTime - totalPausedMs`. Use `setInterval(tick, 1000)` that computes from wall clock, NOT a counter variable. Freeze display when paused (use the pausedAt timestamp for frozen display). Clear interval on unmount.
  - Pause button (Pause icon) when running, Play button when paused
  - End Session button (Square icon) with red accent color
  - Live metrics inline: "Focused: mm:ss" (from focusedMs prop), "Distractions: N" (from distractionCount prop)
- Use `"use client"` directive. Import icons from lucide-react (Play, Pause, Square, Clock, Brain, AlertTriangle).
- Style with dark theme (gray-900 background, border-gray-800, white/gray text). Use framer-motion for button transitions (AnimatePresence for swap between pause/play).
- Timer state lives INSIDE this component only (not lifted to parent) to avoid re-rendering the entire tree.

**SessionTimeline.tsx** - Recharts AreaChart for focus score over time:

- Props: `snapshots: FocusSnapshot[]`, `startTime: number`, `height?: number` (default 200)
- Convert timestamps to elapsed seconds: `(snapshot.time - startTime) / 1000`
- X-axis: elapsed time formatted as mm:ss
- Y-axis: domain [0, 100]
- Area with monotone curve type, blue stroke (#3b82f6), gradient fill from blue/0.4 opacity to blue/0.05 opacity
- ReferenceLine at y=70 with green dashed stroke and "Focus threshold" label
- Tooltip showing score and formatted time
- Use SSR guard pattern (existing in FocusSparkline.tsx): `const [mounted, setMounted] = useState(false); useEffect(() => setMounted(true), [])` and return placeholder if not mounted.
- `isAnimationActive={false}` for performance.

**SessionSummary.tsx** - Post-session summary overlay:

- Props: `session: StoredSession`, `onDismiss: () => void`
- Full-screen overlay with semi-transparent black backdrop (bg-black/60)
- Centered card (max-w-lg) with dark background (bg-gray-900, rounded-xl, border-gray-800)
- Header: "Session Complete" with checkmark icon
- Stats grid (2x2):
  - Total Time: format totalDurationMs as "Xm Ys"
  - Average Score: averageScore rounded to integer, with color coding (green >=70, yellow >=40, red <40)
  - Focused: focusedPercentage with "%" suffix, same color coding
  - Distractions: distractionCount as integer
- SessionTimeline chart below stats, using session.snapshots and session.startTime
- Personal best callout if applicable (passed as optional prop `newBests: string[]`)
- "Done" button at bottom that calls onDismiss
- Use framer-motion for entrance animation (fade in + scale up)
  </action>
  <verify>
```bash
npx tsc --noEmit
grep -rn "export default function" src/components/session/
```
Verify all three components export correctly and have no type errors.
  </verify>
  <done>SessionControls renders start CTA in idle state, timer + pause/resume/end + live metrics in running/paused state. SessionTimeline renders Recharts AreaChart with gradient, reference line, and SSR guard. SessionSummary renders overlay with stats grid, timeline chart, and dismiss button.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite session page and integrate session lifecycle into DetectionProvider</name>
  <files>src/app/session/page.tsx, src/components/detection/DetectionProvider.tsx</files>
  <action>
**Rewrite src/app/session/page.tsx:**

The session page becomes the orchestrator for three UI states based on session phase:

1. Import `useSessionManager` and all session components.

2. Make page.tsx a `"use client"` component (it currently is server-rendered, wrapping ClientDetectionLoader). It now needs to own the session state.

3. Call `useSessionManager()` at the top level. Also maintain a `lastCompletedSession` state (StoredSession | null) to hold the summary data after a session ends.

4. When `session.phase === "idle"`:
   - Render header (existing FocusFlow branding)
   - Render SessionControls in idle mode (shows "Start Focus Session" button)
   - Below: placeholder area for history (Plan 04-03 will fill this). For now, render a simple message like "Your session history will appear here."
   - Detection pipeline is NOT mounted yet (no ClientDetectionLoader). This saves resources.

5. When `session.phase === "running" || session.phase === "paused"`:
   - Render header
   - Render SessionControls in running/paused mode with session state props
   - Render DetectionProvider, passing new props: `sessionPhase`, `onTick` (session.tick), `onDistraction` (session.recordDistraction), `resetScoring` (function that calls reset on score/chime/coaching)
   - Detection pipeline IS mounted

6. When `session.phase === "ended"`:
   - Keep DetectionProvider unmounted (session is over)
   - Render SessionSummary overlay with lastCompletedSession data
   - On dismiss: set lastCompletedSession = null (returns to idle). IMPORTANT: After dismiss, re-compute all dashboard data from localStorage by calling `loadSessions()`, then derive `calculateStreak(sessions)` and `getPersonalBests(sessions)` from the fresh session list. This ensures the pre-session dashboard (Plan 04-03) immediately reflects the just-completed session without requiring a page reload. Implement this as a `refreshDashboardData()` helper called both on mount and on dismiss. Plan 04-03 will consume this state for the StreakBadge, PersonalBests, and SessionHistory components.

7. Wire the `end()` call: when user clicks End, call `session.end()` which returns the StoredSession. Set it as lastCompletedSession. If null (session too short), show a toast/message "Session too short (minimum 60 seconds)" and return to idle.

8. Wire the `start()` call: when user clicks Start, call `session.start()`. Also call all reset functions (score, chime, coaching) to clear state from any previous session.

9. Add `beforeunload` event listener: when session.phase is "running" or "paused", add a listener that triggers the browser's native "Leave page?" dialog. Remove it when session ends or goes idle.

**Modify src/components/detection/DetectionProvider.tsx:**

1. Add new props interface:
```typescript
interface DetectionProviderProps {
  sessionPhase: "running" | "paused";
  onTick: (score: number) => void;
  onDistraction: () => void;
  onResetScoring: () => void;  // Called once on mount to reset scoring state
}
```

2. Accept these props: `{ sessionPhase, onTick, onDistraction, onResetScoring }`

3. On first mount (useEffect with empty deps), call `onResetScoring()` to reset focus score to 100 and clear chime/coaching state. This ensures each session starts fresh.

4. Gate the scoring tick dispatch on `sessionPhase === "running"`:
   - In the useFocusScore hook effect that processes detection results, the TICK action (3-second update) should only fire if session is running
   - However, useFocusScore doesn't know about session phase. Instead, add a `paused` flag to useFocusScore: when paused, skip the 3-second timer check entirely. Expose `setPaused(boolean)` from useFocusScore.
   - Alternative (simpler): In DetectionProvider, wrap the score in a `useEffect` that calls `onTick(score)` whenever score changes AND sessionPhase is "running". This feeds scores into the session manager without modifying useFocusScore's internal timer.

5. For distraction tracking: when chimeCount increases (from useFocusChime), call `onDistraction()` to increment the session's distraction count. Track the previous chimeCount with a ref and dispatch on increase.

6. Remove the existing `detectionStartRef` logic (session start time is now managed by useSessionManager, not by detection readiness).

7. Keep ALL existing detection/scoring/coaching behavior intact. The detection pipeline, scoring algorithm, chime system, and coaching engine continue to function exactly as before. The session lifecycle is layered on top, not replacing any existing logic.

CRITICAL: Detection (webcam + Human.js) MUST keep running even when sessionPhase is "paused". Only the score feeding into the session manager stops. The useFocusScore hook itself keeps computing scores (the display freezes because onTick stops being called, but the internal scoring continues). When resuming, scores immediately flow again.

Actually, simpler approach: Let useFocusScore continue computing normally at all times. The session manager's TICK action already guards on phase === "running" (from Plan 04-01). So just always call `onTick(score)` on score changes -- the reducer will ignore ticks when paused. The UI timer freezes on pause. Score display in the ring can optionally freeze too (show last score before pause).
  </action>
  <verify>
```bash
npx tsc --noEmit
npm run build
```
Manual verification steps:
1. Navigate to /session - see "Start Focus Session" button (no webcam yet)
2. Click Start - webcam activates, calibration runs, scoring begins
3. Timer counts up while running
4. Click Pause - timer freezes, score display freezes, webcam keeps running
5. Click Resume - timer continues, scoring resumes immediately (no re-warmup)
6. Click End - summary overlay appears with stats and timeline chart
7. Click Done - returns to idle state (webcam stops)
8. Refresh page during session - browser shows "Leave page?" warning
  </verify>
  <done>Session page orchestrates idle/running/ended UI states. DetectionProvider accepts session props and feeds scores into session manager. Timer displays wall-clock elapsed time. Pause freezes scoring without stopping detection. End shows summary with timeline chart. beforeunload guard active during sessions.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. Session lifecycle: idle -> start -> running (timer counting) -> pause (timer frozen) -> resume (timer continues) -> end (summary shown) -> dismiss (back to idle)
4. Focus score resets to 100 at session start
5. Detection pipeline does NOT restart on pause/resume
6. Summary shows correct total time, average score, focused %, distraction count
7. Timeline chart renders with score data over session duration
8. beforeunload fires when navigating away during active session
9. Sessions under 60 seconds are not saved
</verification>

<success_criteria>
- Complete session lifecycle works end-to-end with one-click start
- Timer uses wall-clock math (no drift over long sessions)
- Pause/resume is instant (no detection re-warmup)
- Live metrics update in real-time during session
- Summary overlay shows all required stats with timeline chart
- State resets cleanly between sessions
</success_criteria>

<output>
After completion, create `.planning/phases/04-session-management-session-management/04-02-SUMMARY.md`
</output>
